[{"id":"7946cdcdd74bfc50bffd88db84a2af16","title":"她是谁","content":"","slug":"dream-240927","date":"2024-09-28T10:16:00.000Z","categories_index":"Emo","tags_index":"emo,dream","author_index":"RaphaelNY"},{"id":"2818dcba97ab21b0acb9e104daddb083","title":"vscode macOS to Windows","content":"前言\n\n\n\n\n\n\n\n\n前段时间，为了方便办公，我尝试将macOS的vscode工作区链接到Windows的远程服务器上，以便在macOS上编写代码，然后在Windows上运行代码。避免在macOS上安装Windows的开发环境，以及不需要把代码放在MacOS中编译运行（你们都知道的，Apple的硬盘内存卖的比金子还贵）。但是在尝试的过程中，遇到了一些问题，记录如下。\n问题\n\n\n\n\n\n\n\n\n包含ssh安装，配置，密钥认证等相关内容这里就不过多介绍，网络上随便一搜就有很多教程了。\n1. 通过ssh连接到Windows\n通过ssh连接到Windows，可以正常连接，但是在vscode中打开工作区时，会产生报错，一般是ssh Connection time out\n一种可能的问题是由于Windows的防火墙导致的，需要在Windows的防火墙中添加一个入站规则开放22端口，允许ssh连接。\n另一种可能是由于Windows的ssh服务没有启动，需要在Windows的服务中启动ssh服务。\n除去上面的两种问题，就是操作系统的不同了。\n\n\n在新版的vscode中，有这么一个配置，你可以在设置中搜索Remote.SSH.UserLocalServer,在之前使用windows链接Linux服务器时，都没出现过ssh的问题，在第一次链接的时候会询问获取目标服务器的操作系统，如果你选择了错误的操作系统，那么就会导致ssh连接失败，这个时候你需要在vscode的设置中手动修改这个配置项。但是在我尝试的过程中，这个配置项并没有出现（又或者出现了，但我肯定我选择的是正确的），vscode在后续我测试的每次尝试中，都在建立ssh链接之后尝试在我的目标服务器上运行uname -rsv命令，但是这个命令在Windows上默认是不支持的，所以就会导致vscode判定工作区无法建立。\n在网络上进行了多次查询和我自己对设置的相关调试后，最终我通过直接关闭本机上的Remote.SSH.UserLocalServer这个配置项就可以解决这个问题。相比于其他复杂的修改windows的配置，这个方法更加简单（大家都知道，windows的环境是出了名的复杂麻烦）。\n\n2. 通过ssh连接到Windows后尝试提交代码失败（主要是关于gpg的内容）\n可以参考这个博主的详细教程\n另一个问题，就是在我在这边配置结束之后回到windows上尝试提交发现我的windows上的配置也出现了问题，之前一直都能够正常提交。不过在修正了git config之后，就可以正常提交了。出现原因不明。\n谨慎修改配置，mac的vscode连windows给我windows的gpg干死了，修了半天。\n\n","slug":"vscode-macOS-to-Windows","date":"2024-09-18T02:29:32.000Z","categories_index":"VSCode,macOS,Windows","tags_index":"vscode,ssh","author_index":"RaphaelNY"},{"id":"08ab197663d22426d8804f0a11a49fec","title":"Solana Anchor框架 编程学习","content":"前言\n\n\n\n\n\n\n\n\n先在这里开个坑，这算是学习预告？😋\n","slug":"Anchor-learning","date":"2024-09-03T14:00:00.000Z","categories_index":"Rust,区块链","tags_index":"rust,solana,Anchor","author_index":"RaphaelNY"},{"id":"40e410b5347e58401e54ab5e8d97a4e6","title":"熟悉zino框架","content":"intro这次准备基于zino官方的example/actix-app来进行学习，进行代码阅读并参照zino开发文档进行学习记录。\n从example开始熟悉zino框架123456开发环境：windows11rustup 1.27.1rustc 1.84.0postrageSQL更多配置参照cargo.toml\n\n通过actix-app 了解zino框架\n文件目录格式参照：目录结构 - Zino开发框架中文教程\n\n使用类似于Egg.js的应用目录约定规范\n\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657zino-app├─ Cargo.toml├─ config│  ├─ config.dev.toml│  ├─ config.prod.toml│  ├─ locale│  │  ├─ en-US.ftl│  │  └─ zh-CN.ftl│  ├─ opa│  │  └─ user.opa│  └─ openapi│     ├─ OPENAPI.toml│     ├─ auth.toml│     └─ user.toml├─ local│  ├─ data│  │  └─ mock│  │     ├─ logs.ndjson│  │     └─ users.csv│  └─ docs│     └─ rapidoc.html├─ logs├─ public│  ├─ 404.html│  ├─ data│  │  └─ logs.ndjson│  └─ index.html├─ src│  ├─ controller│  │  ├─ mod.rs│  │  ├─ stats.rs│  │  ├─ task.rs│  │  └─ user.rs│  ├─ extension│  │  ├─ casbin.rs│  │  ├─ header.rs│  │  └─ mod.rs│  ├─ logic│  │  ├─ mod.rs│  │  ├─ task.rs│  │  └─ user.rs│  ├─ main.rs│  ├─ middleware│  │  ├─ access.rs│  │  └─ mod.rs│  ├─ router│  │  └─ mod.rs│  ├─ schedule│  │  ├─ job.rs│  │  └─ mod.rs│  └─ service│     ├─ mod.rs│     ├─ task.rs│     └─ user.rs└─ templates   ├─ layout.html   └─ output.html\n\n\nCargo.toml为应用的Cargo配置文件。\nconfig/config.&#123;env&#125;.toml用于编写不同运行环境的配置文件。\nconfig/locale/&#123;lang-id&#125;.ftl于编写i18n多语言文件，目前仅支持Fluent规范。\nconfig/opa/&#123;policy&#125;.rego用于编写OpenPolicyAgent策略。\nconfig/openapi/&#123;tag&#125;.toml用于编写OpenAPI规范文档。\nlocal/为本地静态资源目录，data/为本地数据目录，docs/为文档目录。\nlogs/用于日志文件输出。\npublic/为通过网络访问的静态资源目录，index.html为默认首页文件，404.html为404文件，data/为共享的数据目录。\nsrc/controller/用于编写控制器。\nsrc/extension/用于编写辅助函数。\nsrc/logic/用于编写业务逻辑。\nsrc/main.rs用于启动应用以及自定义初始化。\nsrc/middleware/用于编写中间件。\nsrc/router/用于配置URL路由规则。\nsrc/schedule/用于编写定时任务。\nsrc/service/用于编写业务接口服务，供controller调用。\ntemplates/用于编写HTML模板文件，目前支持Tera和MiniJinja模板。\n\n\n配置文件首先是config下配置的config.{env}.toml文件\nzino框架提供了可供修改的config配置文件来方便设定相关服务信息从而规避需要直接对代码进行修改后重新编译的开销。\n\nname,version配置应用名称和版本号\nmain服务，debug以及备用standby服务均可以单独指定host以及port，支持使用tag标识\n数据库相关配置为[database] [[postgres]] [[sqlite]]。可以将postgres替换为需求的数据库，具体数据库支持请参照zino的相关文档。\n其他重要配置，包括日志追踪、指标监控prometheus、jwt认证、api文档配置等参考实际文件。\n\n示例：\n123456789101112131415[database]namespace = &quot;dc&quot;max-rows = 10000    # 最大行数限制# PostgreSQL 配置[[postgres]]host = &quot;127.0.0.1&quot;port = 5432database = &quot;data_cube&quot;username = &quot;postgres&quot;password = &quot;...&quot;    # 数据库密码# SQLite 配置[[sqlite]]database = &quot;local/data/main.db&quot;\n\n日志文件默认情况下，日志文件log将在logs文件夹下进行保存，命名方式为&#123;name&#125;.&#123;env&#125;.&#123;time&#125;.log\npubliczino推荐将前端静态资源放置在public里面，在项目迁移时，所有前端资源都将被防止在public中进行组织。您可以在src/router中进行路由配置\n\nsrc参考前文提供的文件目录架构，来熟悉以下zino框架下的后端代码组织。本次学习参照的是example/actix-app作为标准代码。下面基于一般性的基础需求进行学习。\n\n\n\n\n\n\n\n\n\nsrc/controller/用于编写控制器。src/extension/用于编写辅助函数。src/logic/用于编写业务逻辑。src/main.rs用于启动应用以及自定义初始化。src/middleware/用于编写中间件。src/router/用于配置URL路由规则。src/schedule/用于编写定时任务。src/service/用于编写业务接口服务，供controller调用。\ndomain extension logic service在本项目中，由于只实现一些十分简单的功能，所以并没有相关这部分的代码可供参考，在此留空，待笔者学成归来。理解上，service大概类似于controller中的部分功能拆分，优化代码构筑和代码可读性。\n\n\n\n\n\n\n\nWARNING\n\n\nrouterrouter下只使用了一个mod文件来存放整个项目的路由信息。\n使用RESTfulAPI的风格设计\nzino框架下的路由实现你可以根据使用的框架自行调整，下面是aticx的实现方式，你使用axum的构建形式，通过形如下述进行实现也是可以的。\n12345678910111213141516pub fn routes() -&gt; Vec&lt;Router&gt; &#123;    let mut routes = Vec::new();    // Auth controller.    let router = Router::new().route(&quot;/auth/login&quot;, post(auth::login)).merge(        Router::new()            .route(&quot;/auth/refresh&quot;, get(auth::refresh))            .route(&quot;/auth/logout&quot;, post(auth::logout))            .layer(from_fn(middleware::init_user_session)),    );    routes.push(router);        ...        routes&#125;\n\n由于zino兼容了主流rust的头部框架，你可以在代码开头看到use actix_web::web::&#123;&#125;;\n\n使用routes()和debug_routes()整合整个路由配置拆分为主要路由和调试路由。主要功能就是把我们准备的各种不同功能的路由分组打包成vec。\n\n代码中使用了形如auth_router as RouterConfigure的语句，参照RouterConfigure源码pub type RouterConfigure = fn(cfg: &amp;mut actix_web::web::ServiceConfig);\n可知RouterConfigure是类型别名，定义了一个函数类型。\n接收一个可变引用&amp;mut actix_web::web::ServiceConfig\n返回空\n\n\n\n\n具体路由方面，路由使用.wrap(middleware::WserSessionInitializer),为需要会话验证的部分指定使用会话中间件进行会话验证\n\nrustfn auth_router(cfg: &amp;mut ServiceConfig) &#123;\n    // 不需要会话验证的路由\n    cfg.route(&quot;/auth/login&quot;, post().to(auth::login));\n    \n    // 需要会话验证的路由组\n    cfg.service(\n        scope(&quot;/auth&quot;)\n            .route(&quot;/refresh&quot;, get().to(auth::refresh))\n            .route(&quot;/logout&quot;, post().to(auth::logout))\n            .wrap(middleware::UserSessionInitializer),  // 添加会话中间件\n    );\n&#125;\n&lt;!--code￼4--&gt;\n\n- 区分controller方法和model方法\n在mod中，我们可以看到分别调用了User和user，里面涉及到使用了zino框架提供的default方法和自己实现的方法，等看到controller的代码之后再进行解决\n\n\n\n\n\n\n\n\n\nWARNING\n\n\nmiddlewaremiddleware中主要定义了一个用于处理Jwt验证的会话中间件\nUserSessionInitializer中间件初始化器，实现了Transform Trait，\n\n在Transform trait中，type的部分定义的是transform的关联类型\n\nnew_transform方法接收一个实现了S要求trait和self，返回前面定义的Future关联类型\n\nS 其实就是服务类型的泛型,标识实际请求的服务\nB是响应体的类型，通常是字节流或者其他内容\nServiceRequest是请求类型，他会传递给这个中间件\nS: Service&lt;ServiceRequest, Response = ServiceResponse&lt;B&gt;, Error = Error&gt;: 这部分约束指定了服务 S 必须是一个能够接受 ServiceRequest 请求并返回 ServiceResponse&lt;B&gt; 响应的服务，而且必须能够处理 Error 错误\nS::Future: &#39;static: 这表示 S 服务的 Future 返回类型必须是 &#39;static，即不会包含生命周期依赖于局部变量的引用\n\n\ntype Transform = UserSessionMiddleware&lt;S&gt;;这是中间件最终产生的类型。在这个实现中，Transform 类型是 UserSessionMiddleware&lt;S&gt;，这意味着该中间件会返回一个 UserSessionMiddleware 类型的对象，它本质上包裹了原始的服务 S\n\nnew_transform用于实际转换服务，并返回一个新的中间件实例\n\n通过UserSessionMiddleware打包service服务并作为ready类型的Future返回。Future包含Ok(UserSessionMiddleware)作为结果\n\n\n\nUserSessionMiddleware用于处理请求，解析JWT，并设置用户会话。\n\ntype Future =   Pin&lt;box&lt;dyn Future&lt;Output = Result&lt;Self::Response, Self::Error&gt;&gt;&gt;&gt;;\n这是call方法的返回类型，代表中间件的异步执行结果。\nPine&lt;Box&lt;dyn Future&lt;...&gt;&gt;&gt;用来包裹Future来满足异步操作和动态分配的需求。\nforward_ready!(service);这是 Actix Web 中间件的宏，用于将服务 service 的 ready 状态转发。它确保在中间件中，ready 状态的判断和转发正确，允许中间件将控制权传递给下游服务\n\n\nlet mut req: Extractor&lt;HttpRequest&gt; =  Request::from(req);将Actix-web的ServiceRequest转换为zino::Request,用于后续调用zino中的相关方法\nreq.parse_jwt_claims(JwtClaims::shared_key())解析Jwt，获取共享密钥，解析并提取声明\n解析成功并返回Jwt声明，可以转换为UserSession（有效的用户会话），将会话数据存入请求\n解析失败 || 会话转换失败，返回拒绝响应\n\n\n解析成果并完成会话创建之后，将会把req重新还原回到ServiceRequest从而能够按照Actix-web的要求继续传递给下游服务{总结，关于在Zino中如何处理request，是兼容actix-web的，在具体的响应处理中，使用zino中已经预先准备好的标准化方法，也就是源代码中的let mut req = Request::from(req);和let req = ServiceRequest::from(req);通过转换req的类型来接入zino的标准化处理，然后还原到actix-web的标准类型中来保持兼容请求传递}\nBox::pin(async move &#123; let res = fut.await?; Ok(res) &#125;)通过 Box::pin 将 fut.await 包装成一个固定的异步任务。在这里，等待实际服务的响应并返回。如果服务响应成功，则返回结果；否则，返回错误\n\nmodel对于model部分，是项目实现的核心。这里将会参照zino crate的文档进行详细阅读。\n123use serde::&#123;Deserialize, Serialize&#125;; // 序列化 反序列化use zino::prelude::*; // zino打包的预导入模块，里面包含了zino的主要常用模块use zino_derive::&#123;DecodeRow, Model, ModelAccessor, ModelHooks, Schema&#125;;\n\nzino::prelude1234567891011121314151617181920212223242526272829pub use zino_core::&#123;    // 应用相关    application::&#123;Application, Plugin&#125;,    state::State,        // 错误处理    error::Error,    bail, warn,        // 时间日期    datetime::&#123;Date, DateTime, Time&#125;,        // JSON扩展    extension::&#123;JsonObjectExt, JsonValueExt, TomlTableExt&#125;,    json,        // 模型相关    model::&#123;Model, ModelHooks, Mutation, Query, QueryContext&#125;,        // 任务调度    schedule::&#123;        AsyncCronJob, AsyncJob, AsyncJobScheduler,        CronJob, Job, JobContext, JobScheduler    &#125;,        // 基础类型    BoxFuture, Decimal, LazyLock, Map, Record, Uuid,    validation::Validation,&#125;;\n\n以及一些feature的可选项，按需取用。\nzino_derive导入过程宏，避免手动实现，zino中的大部分功能都能通过derive过程宏进行实现，详细参照crate的代码。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#![doc = include_str!(&quot;../README.md&quot;)]#![doc(html_favicon_url = &quot;https://zino.cc/assets/zino-logo.png&quot;)]#![doc(html_logo_url = &quot;https://zino.cc/assets/zino-logo.svg&quot;)]#![forbid(unsafe_code)]use proc_macro::TokenStream;use syn::&#123;parse_macro_input, DeriveInput&#125;;mod decode_row;mod entity;mod model;mod model_accessor;mod model_hooks;mod parser;mod schema;#[doc = include_str!(&quot;../docs/entity.md&quot;)]#[proc_macro_derive(Entity, attributes(schema))]pub fn derive_entity(item: TokenStream) -&gt; TokenStream &#123;    let input = parse_macro_input!(item as DeriveInput);    let output = entity::parse_token_stream(input);    TokenStream::from(output)&#125;#[doc = include_str!(&quot;../docs/schema.md&quot;)]#[proc_macro_derive(Schema, attributes(schema))]pub fn derive_schema(item: TokenStream) -&gt; TokenStream &#123;    let input = parse_macro_input!(item as DeriveInput);    let output = schema::parse_token_stream(input);    TokenStream::from(output)&#125;#[doc = include_str!(&quot;../docs/model_accessor.md&quot;)]#[proc_macro_derive(ModelAccessor, attributes(schema))]pub fn derive_model_accessor(item: TokenStream) -&gt; TokenStream &#123;    let input = parse_macro_input!(item as DeriveInput);    let output = model_accessor::parse_token_stream(input);    TokenStream::from(output)&#125;#[doc = include_str!(&quot;../docs/decode_row.md&quot;)]#[proc_macro_derive(DecodeRow, attributes(schema))]pub fn derive_decode_row(item: TokenStream) -&gt; TokenStream &#123;    let input = parse_macro_input!(item as DeriveInput);    let output = decode_row::parse_token_stream(input);    TokenStream::from(output)&#125;#[doc = include_str!(&quot;../docs/model_hooks.md&quot;)]#[proc_macro_derive(ModelHooks, attributes(schema))]pub fn derive_model_hooks(item: TokenStream) -&gt; TokenStream &#123;    let input = parse_macro_input!(item as DeriveInput);    let output = model_hooks::parse_token_stream(input);    TokenStream::from(output)&#125;#[doc = include_str!(&quot;../docs/model.md&quot;)]#[proc_macro_derive(Model, attributes(schema))]pub fn derive_model(item: TokenStream) -&gt; TokenStream &#123;    let input = parse_macro_input!(item as DeriveInput);    let output = model::parse_token_stream(input);    TokenStream::from(output)&#125;\n\n\npub struct Tag代码中为Tag实现了 Debug,Clone,Default,Serialize,eserialize,DecodeRow,Schema,ModelAccessor,ModelHooks,Model,宏。还有一个需要重点了解的#[schema(auto_rename)]\n\nauto_rename:\n\n命名规范转换：\n结构体名称 -&gt; 表名（驼峰转蛇形）\n字段名 -&gt; 列名（驼峰转蛇形）\n\n\n特殊处理：\n保留字段（如 created_at, updated_at 等）\n主键字段（默认为 id）\n引用字段（如 parent_id）\n生成静态元数据\n\n\n\n\nDecodeRow\n\n将定义的字段转换为数据库的列名\n\n\nModelHooks\n\nzino预先继承了有关ORM等的操作，相关可以参考源代码。\n\n在标准实现中，保留有空接口，这些接口你可以通过手动重写来将逻辑插入到zino提供的标准实现中，从而达到个性化业务逻辑需求。比如：\n123456fn x() -&gt; () &#123;    .....    hook1();    ....    hook2();&#125;\n\n通过重写hook1和hook2，从而将个性化业务逻辑插入到标准操作的指定位置，例如写入数据库前后。\n\n\n\nschema\n\n数据库映射：\n定义表结构\n设置字段类型\n创建索引\n建立外键关系\n\n\n验证规则：\n非空检查\n默认值处理\n字段访问控制\n\n\n文档生成：\nAPI文档\n数据库文档\n字段说明\n\n\n代码生成：\nORM方法\nCRUD操作\n模型关联\n\n\n通过标准化语法，来用最少的代码量实现模型定义。\n\n\n\nschedule调度器设计\njob.rs\n主要定义了具体任务实现，例如定时任务等。\n在任务中可以设计异步任务。\n实现同步任务的异步任务的设计\n\nmod.rs配置调度器\n分为同步和异步。简单代码，组织方式就是创建在job中定义的任务，添加设置然后添加到scheduler中作为返回值。\ncontrollerstats12345678910111213141516171819202122pub async fn index(req: Request) -&gt; Result &#123;    // 1. 创建响应对象，并关联请求上下文    let res = Response::default().context(&amp;req);    // 2. 构建统计数据    let stats = json!(&#123;        &quot;method&quot;: &quot;GET&quot;,        &quot;path&quot;: &quot;/stats&quot;,        // 获取集群状态数据        &quot;app_state_data&quot;: Cluster::state_data(),    &#125;);    // 3. 准备模板数据    let data = json!(&#123;        &quot;title&quot;: &quot;Stats&quot;,        // 格式化统计数据        &quot;output&quot;: stats.to_string_pretty(),    &#125;);    // 4. 渲染模板并返回响应    Ok(res.render(&quot;output.html&quot;, data).into())&#125;\n关键点解析：\n\n请求处理：\n\n1pub async fn index(req: Request) -&gt; Result\n\n\n异步处理函数\n\n接收 Request 类型参数\n返回 Result 类型\n\n\n响应构建：\n\n\n1let res = Response::default().context(&amp;req);\n\n\n创建默认响应\n\n关联请求上下文\n\n\n状态数据：\n\n\n12345let stats = json!(&#123;    &quot;method&quot;: &quot;GET&quot;,    &quot;path&quot;: &quot;/stats&quot;,    &quot;app_state_data&quot;: Cluster::state_data(),  // 获取集群状态&#125;);\n\n\n模板渲染：\n\n1Ok(res.render(&quot;output.html&quot;, data).into())\n\n\n使用 output.html 模板\n\n传入 JSON 数据\n转换为响应类型\n\n\n这个控制器的主要功能：\n\n提供应用状态监控\n示集群状态信息\n通过模板渲染数据\n返回 HTML 响应\n\n\n使用场景：\n\n系统监控\n调试信息查看\n状态数据展示\n集群信息监控\n\n\n这是一个典型的 MVC 架构中的控制器实现，负责：\n\n处理请求\n\n获取数据\n\n准备视图\n\n返回响应\n\n\n\n\nuser.rs包含了创建用户和查看用户两个部分。\n\nnew()部分的标准流程： \n创建用户并验证\n检查约束条件\n保存用户\n准备响应数据\n设置响应\n\n\nview():\n获取用户id\n查询用户\n权限检查\n构建响应\n\n\n\nfile.rs\nupload\n12345678910111213141516171819202122232425262728293031323334353637383940pub async fn upload(mut req: Request) -&gt; Result &#123;    // 1. 解析表单数据    let (mut body, files) = req.parse_form_data::&lt;Map&gt;().await?;    // 2. 获取上传目录    let dir = Cluster::shared_dir(&quot;uploads&quot;);    let expires = DateTime::now() + Duration::from_secs(600); // 10分钟过期    let mut encryption_duration = Duration::ZERO;    let mut uploads = Vec::new();    // 3. 处理每个文件    for mut file in files &#123;        // 3.1 生成访问凭证        let mut query = Map::new();        let access_key_id = AccessKeyId::new();        let secret_key = SecretAccessKey::new(&amp;access_key_id);        let security_token = SecurityToken::try_new(            access_key_id,             expires,             &amp;secret_key        ).extract(&amp;req)?;        // 3.2 加密文件        let encryption_start_time = Instant::now();        file.encrypt_with(secret_key.as_ref()).extract(&amp;req)?;        encryption_duration += encryption_start_time.elapsed();        // 3.3 保存文件        if let Some(file_name) = file.file_name() &#123;            file.write(dir.join(file_name)).extract(&amp;req)?;                        // 3.4 准备文件信息            let mut map = Map::new();            map.upsert(&quot;field_name&quot;, file.field_name());            map.upsert(&quot;file_name&quot;, file_name);            map.upsert(&quot;content_type&quot;, file.content_type().map(|m| m.as_ref()));            map.upsert(&quot;url&quot;, format!(&quot;/file/decrypt?&#123;&#125;&quot;, query.to_query_string()));            uploads.push(map);        &#125;    &#125;\n\ndecrypt\n\nrustpub async fn decrypt(req: Request) -&gt; Result &#123;\n    // 1. 验证访问凭证\n    let query = req.parse_query::&lt;Map&gt;()?;\n    let access_key_id = req.parse_access_key_id()?;\n    let secret_key = SecretAccessKey::new(&amp;access_key_id);\n    let security_token = req.parse_security_token(secret_key.as_ref())?;\n    // 令牌过期检查\n    if security_token.is_expired() &#123;\n        reject!(req, forbidden, &quot;the security token has expired&quot;);\n    &#125;\n\n    // 2. 获取文件\n    let Some(file_name) = query.get_str(&quot;file_name&quot;) else &#123;\n        reject!(req, &quot;file_name&quot;, &quot;it should be specified&quot;);\n    &#125;;\n    let file_path = Cluster::shared_dir(&quot;uploads&quot;).join(file_name);\n\n    // 3. 解密并发送文件\n    let mut file = NamedFile::try_from_local(file_path).extract(&amp;req)?;\n    let decryption_start_time = Instant::now();\n    file.decrypt_with(secret_key).extract(&amp;req)?;\n&lt;!--code￼15--&gt;\nrefresh\n123456789101112pub async fn refresh(req: Request) -&gt; Result &#123;    // 1. 解析当前JWT令牌    let claims = req.parse_jwt_claims(JwtClaims::shared_key())?;        // 2. 刷新令牌    let data = User::refresh_token(&amp;claims).await.extract(&amp;req)?;        // 3. 返回新令牌    let mut res = Response::default().context(&amp;req);    res.set_json_data(data);    Ok(res.into())&#125;\n\nrefresh 应该是设计在后台自动刷新的？example中疑似并没有实现调用的功能，{这也是之前没有尝试过的做法呢}\n\n\n\n\n\n\n\n\n\n\nTIP\n\n\n\nlogout\n\nrustpub async fn logout(req: Request) -&gt; Result &#123;\n    // 1. 获取用户会话\n    let user_session = req\n        .get_data::&lt;UserSession&lt;_&gt;&gt;()\n        .ok_or_else(|| warn!(&quot;401 Unauthorized: user session is invalid&quot;))\n        .extract(&amp;req)?;\n    let user_id = user_session.user_id();\n\n    // 2. 更新用户状态\n    let mut mutation = MutationBuilder::&lt;User&gt;::new()\n        .set(Status, &quot;SignedOut&quot;)    // 设置为登出状态\n        .set_now(UpdatedAt)          // 更新时间\n        .inc_one(Version)            // 版本号+1\n        .build();\n        \n    // 3. 执行更新\n    let user: User = User::update_by_id(user_id, &amp;mut mutation)\n        .await\n        .extract(&amp;req)?;\n\n\n重点关注到Jwt的认证，包括令牌生成，令牌解析以及刷新令牌\n\n会话管理： 获取 &amp;&amp; 验证\n\n关于用户状态的设置，.set(Status, &quot;&quot;),如Active，SignedOut\n\n版本控制的部分不是很懂是在做什么\n\n\n\n\n\n\n\n\n\nTIP\n\n\n","slug":"zino-start","date":"2024-09-03T14:00:00.000Z","categories_index":"Zino,后端,Rust","tags_index":"rust,zino","author_index":"RaphaelNY"},{"id":"52d0fe63d1c1ad7c08273efe980dc2ed","title":"Solana escrow合约 编程学习","content":"前言苦于solana入门门槛，对于博主这样的区块链小白而言，确实有些幸苦😭。所以，经过查询，找到了一篇简单的入门教程📖。\n同时，这是本次学习的源文章\n我的相关学习资料会放在我的github仓库中\n\n\n\n\n\n\nTIP\n如果你对於区块链没有任何知识，或者说你完全没了解solana，你也许可以先考虑以下video和文档\n\n📺【Solana开发课】学习使用Rust+JavaScript进行Solana区块链开发 | 掌握 Web3、DApp、NFT、DeFi等产品开发 | 中文字幕\n📖介绍 | Solana中文大全 (solana-cn.com)\n📖Home | Solana Validator (solanalabs.com)\n📖Solana Documentation | Solana\nSolana 智能合约指南 | 登链社区 | 区块链技术社区 (learnblockchain.cn)\n\n这边建议使用②的文档，有一说一④的zh翻译真的是翻一半😤我还是倾向于看人话翻译出来的\n\n\n前期准备安装Solana-cil。我还是推荐使用⚙️Cargo来进行包管理，而不是使用其他途径进行安装🤗装不了建议换网\n1cargo install solana-cli --locked --version 1.9.1\n\n\n注意你的⚙️rust最好使用最新的版本，solana-cil的版本也建议使用最新的，详细可以参考crate.io^1。\n\n项目创建1cargo new escrow --lib\n\n\n\n\n\n\n\nTIP\n注意，下述文件除了.toml文件，其余都在.&#x2F;src&#x2F;目录下\n\n\n123Xargo.toml // 文件名[target.bpfel-unknown.dependencies.std]features = []\n\n1234567891011121314151617Cargo.toml[package]name = &quot;escrow&quot;version = &quot;0.1.0&quot;edition = &quot;2021&quot;[features]no-entrypoint = [][dependencies]arrayref = &quot;0.3.6&quot;solana-program = &quot;2.0.8&quot;thiserror = &quot;1.0&quot;spl-token = &#123;version = &quot;6.0.0&quot;, features = [&quot;no-entrypoint&quot;]&#125;[lib]crate-type = [&quot;cdylib&quot;, &quot;lib&quot;]\n\n\n第一个项目要学习的是一个托管合约，主要是解决交易中的去信任问题。\n在区块链中，智能合约双方均可见，属于天然的可信第三方👮‍♂️。\n不过，理论是理论🤗solana并不完全适用，因为solana合约是可以升级的，有可能你看到的不一定是被部署的，不过这都不重要🤔我们暂时涉及不到那个部分\n\n\n\n\n\n\n\n\n\n\n基于我个人的理解，智能合约就是承担一笔交易的第三方担保，用来保证一场交易中不会产生交易双方由于无法信任对方或者缺少可信任的第三方导致交易无法正常进行。打个不恰当的比喻，有点像是通过支付宝 || 微信进行的交易，大家都能够完全的信任，就是因为他们在我们的交易中提供了资金交流的保证。\n\n\n\n\n\n\nTIP\n在Solana区块链中，智能合约是无状态的，不能保存任何数据。所有需要保存的数据均保存在账号的data字段中。\n关于Spl-token及账号相关的一些基础知识请读者自行阅读相应文章或者源教学文章。\n\n\n\n在src目录下创建error.rs ,instruction.rs, processor.rs,entrypoint.rs,state.rs稍后我们将在这些文件中撰写代码\n\n编写基本框架\n\n\n\n\n\n\n\n\n下面会先放源码，再放我的个人理解，只想看代码的可以通过大纲进行跳转。\nError.rs12345678910111213141516use thiserror::Error;use solana_program::program_error::ProgramError;#[derive(Error,Debug,Copy,Clone)]pub enum EscrowError &#123;    // Invalid instruction    #[error(&quot;Invalid Instruction&quot;)]    InvalidInstruction,&#125;impl From&lt;EscrowError&gt; for ProgramError &#123;    fn from(e: EscrowError) -&gt; Self &#123;        ProgramError::Custom(e as u32)    &#125;&#125;\n\n\n\n\n\n\n\n\n\n\n这里使用thiserror的原因原文中写的很明确，省去我们手动实现相关Trait。\n\nsolana程序的返回值通常为ProgramError,所以我们在这里为ProgramError枚举中的所有类型实现FromTrait转换为EscrowError\n\ninstruction.rs12345678910111213141516171819202122232425262728293031323334353637383940414243use std::convert::TryInto;use crate::error::EscrowError::InvalidInstruction;use solana_program::program_error::ProgramError;pub enum EscrowInstruction &#123;    /// 因为要在初始化里转移临时代币账号所有权，所以需要原owner签名，并且原owner也是初始化者    /// 0. `[signer]` The account of the person initializing the escrow    /// 1. `[writable]` Temporary token account that should be created prior to this instruction and owned by the initializer    /// 2. `[]` The initializer&#x27;s token account for the token they will receive should the trade go through    /// 3. `[writable]` The escrow account, it will hold all necessary info about the trade.    /// 4. `[]` The rent sysvar    /// 5. `[]` The token program    InitEscrow &#123;        /// The amount party A expects to receive of token Y        amount: u64    &#125;&#125;impl EscrowInstruction &#123;    pub fn unpack(input: &amp;[u8]) -&gt; Result&lt;Self, ProgramError&gt; &#123;        let (tag, rest) = input.split_first().ok_or(InvalidInstruction)?;                Ok(match tag &#123;            0 =&gt; Self::InitEscrow &#123;                amount: Self::unpack_amount(rest)?,            &#125;,            //注意这里的用法，InvalidInstruction转化为ProgramError时，使用了into          \t//因为我们在error.rs中已经实现了那个from，系统会自动帮我们实现into            _ =&gt; return Err(InvalidInstruction.into()),        &#125;)    &#125;    //这里学习Input 转化为u64    fn unpack_amount(input: &amp;[u8]) -&gt; Result&lt;u64, ProgramError&gt; &#123;        let amount = input            .get(..8)            .and_then(|slice| slice.try_into().ok())            .map(u64::from_le_bytes)            .ok_or(InvalidInstruction)?;        Ok(amount)    &#125;&#125;\n\n\n在这段代码里准备一份初始化指令，编写unpack函数用来将输入数据解析为一个指令\n\n后续添加新的指令继续在unpack函数中添加内容即可。注意函数返回类型Result&lt;Self, ProgramError&gt;\n\n由于input是&amp;[u8]类型，我们在初始化代币所有权中使用了amount: u64,所以我们需要编写一个类型转换，从input中切取代表amount的部分。\n\n整个过程的目的是尝试从 input 的前 8 个字节中读取一个 u64 值：\n获取前 8 个字节：通过 input.get(..8) 尝试获取切片的前 8 个字节。\n转换切片到数组：使用 .and_then 和 try_into() 将字节切片转换为一个固定大小的字节数组 [u8; 8]。\n**转换字节数组到 u64**：使用 map(u64::from_le_bytes) 将 [u8; 8] 转换为 u64。\n错误处理：如果任何一步失败，返回 InvalidInstruction 错误。\n\n\n\n\n\nprocessor.rs12345678910111213141516171819202122232425262728293031323334353637use solana_program::&#123;    account_info::&#123;next_account_info,AccountInfo&#125;,    entrypoint::ProgramResult,    program_error::ProgramError,    msg,    pubkey::Pubkey,&#125;;use crate::instruction::EscrowInstruction;pub struct Processor;impl Processor &#123;    pub fn process(program_id: &amp;Pubkey, accounts: &amp;[AccountInfo], instruction_data: &amp;[u8]) -&gt; ProgramResult &#123;        let instruction = EscrowInstruction::unpack(instruction_data)?;                match instruction &#123;            EscrowInstruction::InitEscrow &#123;amount&#125; =&gt; &#123;                msg!(&quot;Instruction: InitEscrow&quot;);                Self::process_init_escrow(accounts,amount,program_id)            &#125;        &#125;    &#125;    fn process_init_escrow(        accounts: &amp;[AccountInfo],        amount: u64,        program_id: &amp;Pubkey    ) -&gt; ProgramResult &#123;        let account_info_iter = &amp;mut accounts.iter();        let initializer = next_account_info(account_info_iter)?;        if !initializer.is_signer &#123;            return Err(ProgramError::MissingRequiredSignature);        &#125;\t\t\t\t// todo        Ok(())    &#125;&#125;\n\n\n\n\n\n\n\nTIP\n\n这里一般为固定的Processor结构体（只是约定，无强制力）。在该结构体上创建一个静态函数process来处理入口转发过来的参数。在该函数内部，首先解析指令，然后根据指令调用相应的处理函数。\nprocessor返回的是ProgramResult。\n函数体中?操作符的使用，向上级调用传递错误。\n\n\nprocess_init_escrow并没有完全编写🤗后续会进行编写\n\n\n\nentrypoint.rs12345678910111213141516171819//! Program entrypointuse crate::&#123;processor::Processor&#125;;use solana_program::&#123;    account_info::AccountInfo,     entrypoint,     entrypoint::ProgramResult,    pubkey::Pubkey,&#125;;entrypoint!(process_instruction);fn process_instruction(    program_id: &amp;Pubkey,    accounts: &amp;[AccountInfo],    instruction_data: &amp;[u8],) -&gt; ProgramResult &#123;    Processor::process(program_id, accounts, instruction_data) &#125;\n\n\n这部分在lib.rs中声明mod的时候，需要设定可关闭entrypoint特性，为了程序可以方便的被其他程序导入（这里原文中也只是指出了方法，是参考spl-token中的设置和编写而来的）^2\n\n这段代码是solana的入口点实现代码。负责接收和处理来自客户端的交易请求。入口点函数定义了如何处理指令数据、账户信息以及程序ID\n\nentrypoint! 是一个宏，用于定义Solana程序的入口点函数。在Solana中，每个程序必须有且只能有一个入口点函数。\n\nentrypoint!(process_instruction) 告诉编译器，process_instruction 函数是该程序的入口点函数。Solana运行时会在每次程序被调用时执行这个函数。\n\n\nfn process_instruction:\n\nprogram_id: &amp;Pubkey: 表示当前正在执行的程序的公钥。这是Solana用来验证这个程序的标识符。\naccounts: &amp;[AccountInfo]: 一个账户信息的切片，包含了所有在这个交易中涉及的账户。每个 AccountInfo 包含关于账户的详细信息，例如公钥、余额、所有者和数据。\ninstruction_data: &amp;[u8]: 一个字节数组，包含了客户端传递给程序的指令数据。这个数据通常包含操作码和相关的参数，指示程序应该执行什么操作。\n\n\n\nstate.rs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576use solana_program::&#123;    program_pack::&#123;IsInitialized, Pack, Sealed&#125;,    program_error::ProgramError,    pubkey::Pubkey,&#125;;pub struct Escrow &#123;    pub is_initialized: bool,    pub initializer_pubkey: Pubkey,    pub temp_token_account_pubkey: Pubkey,    pub initializer_token_to_receive_account_pubkey: Pubkey,    pub expected_amount: u64,&#125;impl Sealed for Escrow &#123;&#125;impl IsInitialized for Escrow &#123;    fn is_initialized(&amp;self) -&gt; bool &#123;        self.is_initialized    &#125;&#125;use arrayref::&#123;array_mut_ref, array_ref, array_refs, mut_array_refs&#125;;impl Pack for Escrow &#123;    const LEN: usize = 105;    fn unpack_from_slice(src: &amp;[u8]) -&gt; Result&lt;Self, ProgramError&gt; &#123;        let src = array_ref![src, 0, Escrow::LEN];        let (            is_initialized,            initializer_pubkey,            temp_token_account_pubkey,            initializer_token_to_receive_account_pubkey,            expected_amount,        ) = array_refs![src, 1, 32, 32, 32, 8];        let is_initialized = match is_initialized &#123;            [0] =&gt; false,            [1] =&gt; true,            _ =&gt; return Err(ProgramError::InvalidAccountData),        &#125;;        Ok(Escrow &#123;            is_initialized,            initializer_pubkey: Pubkey::new_from_array(*initializer_pubkey),            temp_token_account_pubkey: Pubkey::new_from_array(*temp_token_account_pubkey),            initializer_token_to_receive_account_pubkey: Pubkey::new_from_array(*initializer_token_to_receive_account_pubkey),            expected_amount: u64::from_le_bytes(*expected_amount),        &#125;)    &#125;    fn pack_into_slice(&amp;self, dst: &amp;mut [u8]) &#123;        let dst = array_mut_ref![dst, 0, Escrow::LEN];        let (            is_initialized_dst,            initializer_pubkey_dst,            temp_token_account_pubkey_dst,            initializer_token_to_receive_account_pubkey_dst,            expected_amount_dst,        ) = mut_array_refs![dst, 1, 32, 32, 32, 8];        let Escrow &#123;            is_initialized,            initializer_pubkey,            temp_token_account_pubkey,            initializer_token_to_receive_account_pubkey,            expected_amount,        &#125; = self;        is_initialized_dst[0] = *is_initialized as u8;        initializer_pubkey_dst.copy_from_slice(initializer_pubkey.as_ref());        temp_token_account_pubkey_dst.copy_from_slice(temp_token_account_pubkey.as_ref());        initializer_token_to_receive_account_pubkey_dst.copy_from_slice(initializer_token_to_receive_account_pubkey.as_ref());        *expected_amount_dst = expected_amount.to_le_bytes();    &#125;&#125;\n\n\n\n\n\n\n\nTIP\n\n相同目录创建state.rs，文件用来定义状态保存对象并编写相应的程序处理序列化和反序列化^3（也就是将字节数组和数据结构相互转换）\n我们的结构需要实现program_pack::&#123;IsInitialized, Pack, Sealed&#125; 这三个特型。\nconst LEN: usize = 105;这里结构的大小是根据各个字段的大小相加得到的，分别为1 + 32*3 + 8 = 105。\nunpack_from_slice与pack_into_slice并不是直接被程序的其它部分调用的，Pack特型有两个默认函数，分别调用这两个函数。\n注意array_mut_ref, array_ref, array_refs, mut_array_refs这几个宏的用法，看名字就能猜到，分别为得到一个数组的可变引用，得到一个数组的引用 ，得到多个数组的引用，得到多个数组的可变引用。\n注意示例中从字节数组得到公钥的方法copy_from_slice\n示例中从字节数组得到u64采用了to_le_bytes左对齐的方式，Rust中还有类似的右对齐方式。但一般Solana中采用类C的左对齐方式。\n布尔值可以直接转换为u8，见is_initialized as u8。\n\n\n\n\nPackTrait\nLEN: 定义了Escrow结构体的字节大小（1 + 32 + 32 + 32 + 8 &#x3D; 105 字节）\n\n\nunpack_from_slice:\n从字节切片中重建Escrow结构体（你可以理解为，通信时使用的是字节流，字节流需要重建为结构体才能被使用）\n使用array_refs!宏将源字节切片分割为五个部分，并且映射到Escrow结构体\n模式匹配转换is_initialized\n其他字段均通过转换或者字节数组中构造得到\n\n\npack_into_slice:\n将Escrow结构体的内容打包回一个字节切片\n使用mut_array_refs!宏将目标切片分割为五个可变部分\n将结构体的字段转换为字节并复制到相应的切片部分\n\n\n\nlib.rs123456#[cfg(not(feature = &quot;no-entrypoint&quot;))]mod entrypoint;pub mod error;pub mod instruction;pub mod processor;pub mod state;\n\n完善 processor.rs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657fn process_init_escrow(accounts: &amp;[AccountInfo], amount: u64, program_id: &amp;Pubkey) -&gt; ProgramResult &#123;    let account_info_iter = &amp;mut accounts.iter();    let initializer = next_account_info(account_info_iter)?;    if !initializer.is_signer &#123;        return Err(ProgramError::MissingRequiredSignature);    &#125;    let temp_token_account = next_account_info(account_info_iter)?;    let token_to_receive_account = next_account_info(account_info_iter)?;    if *token_to_receive_account.owner != spl_token::id() &#123;        return Err(ProgramError::IncorrectProgramId);    &#125;    let escrow_account = next_account_info(account_info_iter)?;    let rent = &amp;Rent::from_account_info(next_account_info(account_info_iter)?)?;    if !rent.is_exempt(escrow_account.lamports(), escrow_account.data_len()) &#123;        return Err(EscrowError::NotRentExempt.into());    &#125;    let mut escrow_info = Escrow::unpack_unchecked(&amp;escrow_account.data.borrow())?;    if escrow_info.is_initialized() &#123;        return Err(ProgramError::AccountAlreadyInitialized);    &#125;    escrow_info.is_initialized = true;    escrow_info.initializer_pubkey = *initializer.key;    escrow_info.temp_token_account_pubkey = *temp_token_account.key;    escrow_info.initializer_token_to_receive_account_pubkey = *token_to_receive_account.key;    escrow_info.expected_amount = amount;    Escrow::pack(escrow_info, &amp;mut escrow_account.try_borrow_mut_data()?)?;    let (pda, _bump_seed) = Pubkey::find_program_address(&amp;[b&quot;escrow&quot;], program_id);    let token_program = next_account_info(account_info_iter)?;    let owner_change_ix = spl_token::instruction::set_authority(        token_program.key,        temp_token_account.key,        Some(&amp;pda),        spl_token::instruction::AuthorityType::AccountOwner,        initializer.key,        &amp;[]    )?;    msg!(&quot;Calling the token program to transfer token account ownership...&quot;);    invoke(        &amp;owner_change_ix,        &amp;[            temp_token_account.clone(),            initializer.clone(),            token_program.clone()        ]    )?;    Ok(())&#125;\n\n\n修改use crate::instruction::EscrowInstruction;为use crate::&#123;instruction::EscrowInstruction, error::EscrowError, state::Escrow&#125;;\n\nrustuse solana_program::&#123;\n    account_info::&#123;next_account_info, AccountInfo&#125;,\n    entrypoint::ProgramResult,\n    program_error::ProgramError,\n    msg,\n    pubkey::Pubkey,\n    program_pack::&#123;Pack, IsInitialized&#125;,\n    sysvar::&#123;rent::Rent, Sysvar&#125;,\n    program::invoke\n&#125;;\n&lt;!--code￼11--&gt;\n\n\nprocessor.rs需要转代币账号所有权，调用spl-token的相关函数生成指令\n主要功能：\n验证用于接收代币的账号是否存在\n验证交易账号是否免租金（注意了解相关概念）\n验证交易账号未初始化过（我还没理解，说法是只能初始化一次🤔留一个todo!()在这好了🤗）\n把交易账号的保存数据初始化写回区块链中（参见Escrow::pack函数）\n转让临时代币账号的所有权\n\n\n\n本地编译部署\n\n\n\n\n\n\nWARNING\nsolana-install 工具已被弃用，并将在 Solana 版本 1.18 不再支持后停止使用!\n\n如果你提前安装了，并且安装的时solana-install的更高版本，那么恭喜你！重装吧🤗反正我重装了，主要是后续使用cargo-build-bpf不能正常调取到命令😤，同时教程中使用了cargo build-bpf,很奇怪，我安装了但是跑不了这个命令，好像没有写入到cargo里面🤔也可能是windows的问题\n（再次吐槽windows的教程兼容性，真的烂，方便的还是转战moc OS或者Linux吧🤗🤗）\n\n\n\n\n\n\n\n\n\n\n\n\n吐槽结束！接下来是正经教学\n\n\n\n\n\n\n\n\n\n以下是参考的csdn：\n编译合约，打开终端切换到项目根目录，运行cargo build-bpf --manifest-path=./Cargo.toml --bpf-out-dir=dist/program并忽视那些警告（那是下一步使用的）。编译完成后会给出部署命令。\n启动本地节点。打开一个终端运行solana-test-validator启动本地节点。\n进行本地配置。另外打开一个终端，运行solana config get看是否指向了本地节点，如果不是，运行solana config set --url http://localhost:8899 进行设置。然后运行solana balance，你会发现你拥有 500000000 个SOL。-_- !!!\n运行编译时给出的部署命令:\nsolana program deploy ..../escrow/target/deploy/escrow.so1最后得到一个程序ID，需要记下来，例如我们的为:HEptwBGd4ShMYP6vNCE6vsDmuG3bGzQCcRPHfapvNeys\n接下来，假如你是windows且在这部多次遇到困难，你可以看看我的解决方案：\n\n通过agave的relase下载agave-install-init[^4]，在cmd中运行：agave-install-init-x86_64-pc-windows-msvc.exe v1.18.22 如果安装没问题，你的agave-install和cargo-build-bpf都应该能正常运行？能找到命令就没问题然后你就能接着上面继续跟随操作了，记得用cargo-build-bpf\n\n如果报权限问题，就用管理员权限，我会在后续提供我的解决方案（使用bat脚本，这样你只要在你的编辑器自带terminal运行了，虽然会再开一个终端但是问题不大，大大简化操作了）\n\n对了，额外说一句，我没有看到500000000 个SOL在我误打误撞尝试了solana airdrop 2和solana airdrop 1000以及 solana airdrop 1000 -k id.json我的账户出现了500000000 SOL不知道怎么出现的，不过问题应该不大🤗\n\nbash没有配置大概会变成这样\n&gt; solana balance\nError: Dynamic program error: No default signer found, run &quot;solana-keygen new -o C:\\Users\\Raphaeltop\\.config\\solana\\id.json&quot; to create a new one\n&lt;!--code￼12--&gt;\n1、创建Alice账号并领取空投SOL作为手续费\n2、部署spl-token合约，这个已经默认包含在本地节点了,地址为:TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA。\n3、部署spl-associated-token-account合约，默认已有，地址为:ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\n4、发行X和Y两种代币。\n5、创建Alice在X代币和Y代币的账号（主账号，这里使用唯一的代币关联地址）。\n6、给Alice增发足够数量的X代币进行测试\n&lt;!--code￼13--&gt;\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115const &#123;    Keypair,    Transaction,    LAMPORTS_PER_SOL,    Connection,    sendAndConfirmTransaction&#125; = require(&#x27;@solana/web3.js&#x27;);const &#123;Token,ASSOCIATED_TOKEN_PROGRAM_ID,TOKEN_PROGRAM_ID&#125; = require(&#x27;@solana/spl-token&#x27;);const rpcUrl = &quot;http://localhost:8899 &quot;;const connection = new Connection(rpcUrl, &#x27;confirmed&#x27;);const initSupplyTokenX = 100000000;async function prepair() &#123;    //创建Alice账号领取空投    const alice = Keypair.generate()    signer = alice;    console.log(showWallet(alice))    let  aliceAirdropSignature = await connection.requestAirdrop(        alice.publicKey,        LAMPORTS_PER_SOL,    );    await connection.confirmTransaction(aliceAirdropSignature);    let lamports = await connection.getBalance(alice.publicKey);    console.log(&quot;Alice lamports:&quot;,lamports)    //发行代币X    let tokenX = await Token.createMint(        connection,        alice,        alice.publicKey,        null,        9,        TOKEN_PROGRAM_ID    )    console.log(&quot;tokenX:&quot;,tokenX.publicKey.toBase58())    //创建Alice的X代币关联账号并且增发代币    let alice_x = await createAssociatedAccout(tokenX,alice.publicKey,alice,true)    let info = await tokenX.getAccountInfo(alice_x,&quot;confirmed&quot;)    info.owner = info.owner.toBase58()    info.mint = info.mint.toBase58()    info.address = info.address.toBase58()    console.log(&quot;alice_x:&quot;,info)    //创建tokenY    let tokenY = await Token.createMint(        connection,        alice,        alice.publicKey,        null,        9,        TOKEN_PROGRAM_ID    )    console.log(&quot;tokenY:&quot;,tokenY.publicKey.toBase58())    //创建alice在tokenY的关联账号    let alice_y = await createAssociatedAccout(tokenY,alice.publicKey,alice,false)    console.log(&quot;alice_y_publicKey:&quot;,alice_y.toBase58())&#125;//创建关联地址并增发代币async function createAssociatedAccout(tokenObj,owner,signer,isMint) &#123;    //第一步，计算关联地址    let associatedAddress = await getAssociatedTokenAddress(        TOKEN_PROGRAM_ID,        tokenObj.publicKey,        owner    )    //第二步 创建关联账号（此时ASSOCIATED_TOKEN_PROGRAM会自动进行初始化）    let transaction = new Transaction()    transaction.add(        Token.createAssociatedTokenAccountInstruction(          ASSOCIATED_TOKEN_PROGRAM_ID,          TOKEN_PROGRAM_ID,          tokenObj.publicKey,          associatedAddress,          owner,          signer.publicKey,        )    );    // 第三步 增发代币    if(isMint) &#123;        transaction.add(            Token.createMintToInstruction(              TOKEN_PROGRAM_ID,              tokenObj.publicKey,              associatedAddress,  //注意这里是给关联地址增发              owner,              [],              initSupplyTokenX,            )        )    &#125;    // 第四步 发送交易    await sendAndConfirmTransaction(        connection,        transaction,        [signer]    )    return associatedAddress&#125;async function getAssociatedTokenAddress(programId,mint,account) &#123;    let newAccount = await Token.getAssociatedTokenAddress(        ASSOCIATED_TOKEN_PROGRAM_ID, //关联地址固定公钥        programId,      // 代币合约公钥        mint,            //mint(代币)标识/公钥        account,            //玩家主账号 公钥    )    return newAccount&#125;function showWallet(wallet) &#123;    let result = [wallet.publicKey.toBase58(),Buffer.from(wallet.secretKey).toString(&quot;hex&quot;)]    return result&#125;prepair().then(() =&gt; console.log(&quot;over&quot;))\n\n\n主要功能：\n\n创建一个新账户alice并获取airdrop\n创建和管理代币（tokens）\n创建关联的代币账户（Associated token accounts）\n增发代币（mint tokens）\n\n\n导入模块部分：（虽然这部分不是很重要，但是题主还不熟悉，所以为了方便回顾还是罗列了😎）\n\nKeypair: 用于生成新的公私钥对，代表 Solana 中的一个账户。\nTransaction: 表示一次交易，允许你在区块链上组合多个指令一起执行。\nLAMPORTS_PER_SOL: Solana 上 1 SOL 的单位等于 10亿 Lamports。\nConnection: 用于连接到 Solana 区块链网络的客户端。\nsendAndConfirmTransaction: 发送并确认交易。\nToken: 提供 SPL 代币（Solana 上的代币标准）的相关操作方法。\nASSOCIATED_TOKEN_PROGRAM_ID 和 TOKEN_PROGRAM_ID: 是与代币账户操作相关的 Solana 程序的标识符\n\n\n创建链接和初始供应量：\n\nrpcUrl: 指定连接到本地运行的 Solana 节点的 RPC URL。\nconnection: 与 Solana 区块链的连接对象。\ninitSupplyTokenX: 初始供应量，表示 TokenX 发行的初始数量。\n\n\nprepair 函数主函数，执行代币创建和账户管理操作\n\n创建 Alice 账号:\n\nKeypair.generate() 创建一个新的密钥对（即 Alice 的账户）。\n请求空投（Airdrop）1 SOL 给 Alice 的账户，并确认这笔交易。\n\n\n**发行代币TokenX**：\n\nToken.createMint: 创建一个新的代币（TokenX）。\nconnection: 用于链上操作的连接对象。\nalice: 代币创建者的 Keypair（即 Alice）。\nalice.publicKey: 代币的初始授权者。\nnull: 表示代币不允许冻结账户。\n9: 代币的小数位数（表示代币的精度，和 SOL 一样有9个小数位）。\nTOKEN_PROGRAM_ID: 代币程序的标识符。\n\n\n\n\n创建Alice的代币X关联账户并增发代币\n\njslet alice_x = await createAssociatedAccout(tokenX,alice.publicKey,alice,true)\n&lt;!--code￼15--&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n关键点总结\nAlice账户：作为个人账户，它持有SOL和代币铸造权限，控制TokenX和TokenY的增发。\nTokenX和TokenY代币：由Alice账户铸造，可以在相关的关联账户中持有。\n关联账户（ATA）：专门用于持有某种特定代币（如TokenX或TokenY）的账户，由其关联的用户账户（Alice账户）控制。\n代币与关联账户的关系：每个关联账户（ATA）只能持有一种特定的代币，与创建该关联账户的主账户（如Alice）有直接的关联关系。\n\n\n让Alice账户可以管理多个代币，并使用相关的关联账户来分别持有和操作这些代币\n\n\n::: warning\n注意，大概率是版本更新的问题，这份代码已经跑不了了🤗博主已经各位尝试了，花了很多的时间，结论是跑不了。这边准备换去调框架了，但是还是会把后续看完的，基础还是要看看的📖\n:::\n测试托管合约初始化\n\n\n\n\n\n\n\n\n1、创建一个被token合约拥有的空的账号2、将这个空的账号初始化为Alice的X代币账号（临时账号）3、Alice将她的代币X从主账号转移到临时账号4、创建一个被托管合约拥有的空账号5、将这个空账号初始化为交易状态账号并且将Alice的临时X代币账号转移到PDA（程序派生账号）。\n注意，合约部署时的地址其实在编译后是可以拿到的，使用solana address -k .../....so就可以获取了\n在/test/目录下建立init.js\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108const &#123;    Keypair,    PublicKey,    Transaction,    TransactionInstruction,    SystemProgram,    Connection,    SYSVAR_RENT_PUBKEY,    sendAndConfirmTransaction&#125; = require(&#x27;@solana/web3.js&#x27;);const &#123;Token,TOKEN_PROGRAM_ID&#125; = require(&#x27;@solana/spl-token&#x27;);const BufferLayout = require(&quot;buffer-layout&quot;);const BN = require(&quot;bn.js&quot;);const rpcUrl = &quot;http://localhost:8899 &quot;;const connection = new Connection(rpcUrl, &#x27;confirmed&#x27;);//我们的托管程序地址const escrowProgramId = new PublicKey(&quot;HEptwBGd4ShMYP6vNCE6vsDmuG3bGzQCcRPHfapvNeys&quot;)//从私钥中恢复alice的钱包const alice_privateKey = &quot;49372f691baa9cb4f6d5f485e43b685adb26055cdc545728bd2ff808d0bf92ea870d687c5de0f7eac13cd6050b1c78e23345575ca4b2fc241d65705983015eb1&quot;const alice = Keypair.fromSecretKey(Uint8Array.from(Buffer.from(alice_privateKey, &#x27;hex&#x27;)))//从代币X地址中恢复代币X对象const token_x = new PublicKey(&quot;FMYttGRGuYCrgqCRZLhLoUESqo9Sfe87DKdH7JLZGB6G&quot;)const tokenX = new Token(connection,token_x,TOKEN_PROGRAM_ID,alice)//Alice在代币X的关联账号（公钥）const alice_x = new PublicKey(&quot;6fBN3uzsDKfG2nDLnpP4NknMocQX85AB1vqCWfXbW9os&quot;)const alice_y = &quot;Bu8Heft6Lsih32Z6yaVFQqVndDtzAmJdMS8friSLb59w&quot;const publicKey = (property) =&gt; &#123;    return BufferLayout.blob(32, property);&#125;;  const uint64 = (property) =&gt; &#123;    return BufferLayout.blob(8, property);&#125;;const ESCROW_ACCOUNT_DATA_LAYOUT = BufferLayout.struct([    BufferLayout.u8(&quot;isInitialized&quot;),    publicKey(&quot;initializerPubkey&quot;),    publicKey(&quot;initializerTempTokenAccountPubkey&quot;),    publicKey(&quot;initializerReceivingTokenAccountPubkey&quot;),    uint64(&quot;expectedAmount&quot;),]);const SWAP_AMOUNT = 1000;    //计划交易的X数量const expectedAmount = 1200; //期望得到的Y数量const Escrow_Size = ESCROW_ACCOUNT_DATA_LAYOUT.span; //105，托管合约中交易账号数据大小，其实我们在合约state.rs中已经知道大小了async function init() &#123;    //创建Alice在X代币的临时账号,这里使用SDK自动帮我们创建了。    let temp_account = await tokenX.createAccount(alice.publicKey)    //转移X代币指令    const transaction = new Transaction().add(        Token.createTransferInstruction(          TOKEN_PROGRAM_ID,          alice_x,          temp_account,          alice.publicKey,          [],          SWAP_AMOUNT,        ),    );    const escrowAccount = Keypair.generate() //产生一个随机公/私钥对    console.log(&quot;escrowAccount:&quot;,escrowAccount.publicKey.toBase58())    //创建托管账号指令    const createEscrowAccountIx = SystemProgram.createAccount(&#123;        space: Escrow_Size,        lamports: await connection.getMinimumBalanceForRentExemption(Escrow_Size, &#x27;confirmed&#x27;),        fromPubkey: alice.publicKey,        newAccountPubkey: escrowAccount.publicKey,        programId: escrowProgramId    &#125;);    transaction.add(createEscrowAccountIx)    //初始化托管账号指令    const initEscrowIx = new TransactionInstruction(&#123;        programId: escrowProgramId,        keys: [            &#123; pubkey: alice.publicKey, isSigner: true, isWritable: false &#125;,            &#123; pubkey: temp_account, isSigner: false, isWritable: true &#125;,            &#123; pubkey: alice_y, isSigner: false, isWritable: false &#125;,            &#123; pubkey: escrowAccount.publicKey, isSigner: false, isWritable: true &#125;,            &#123; pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false&#125;,            &#123; pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false &#125;,        ],        data: Buffer.from(Uint8Array.of(0, ...new BN(expectedAmount).toArray(&quot;le&quot;, 8)))    &#125;)    transaction.add(initEscrowIx)    //发送交易    await sendAndConfirmTransaction(        connection,        transaction,        [alice,escrowAccount] //这里要创建escrowAccount，所以它必须签名    )    const encodedEscrowState = (await connection.getAccountInfo(escrowAccount.publicKey,&#x27;confirmed&#x27;)).data;    const decodedEscrowState = ESCROW_ACCOUNT_DATA_LAYOUT.decode(encodedEscrowState)    let info = &#123;        isInitialized:decodedEscrowState.isInitialized === 1,        initializerPubkey:new PublicKey(decodedEscrowState.initializerPubkey).toBase58(),        initializerTempTokenAccountPubkey:new PublicKey(decodedEscrowState.initializerTempTokenAccountPubkey).toBase58(),        initializerReceivingTokenAccountPubkey:new PublicKey(decodedEscrowState.initializerReceivingTokenAccountPubkey).toBase58(),        expectedAmount:new BN(decodedEscrowState.expectedAmount, 10, &quot;le&quot;).toNumber()    &#125;    console.log(&quot;EscrowState:&quot;,info)&#125;init().then(() =&gt; console.log(&quot;over&quot;))\n\n12yarn add buffer-layoutyarn add bn.js\n\n后面没什么重要内容了⚙️请期待后续的新内容🤗\n","slug":"Solana-coding-learning","date":"2024-09-01T14:56:16.000Z","categories_index":"Rust,区块链","tags_index":"rust,solana","author_index":"RaphaelNY"},{"id":"8c17d3487aed17c3a795749d1b71c388","title":"碎碎念的emo情绪","content":"","slug":"emo-time","date":"2024-04-27T16:00:00.000Z","categories_index":"Emo","tags_index":"emo","author_index":"RaphaelNY"},{"id":"3b9e33d00820bf2a8cfa74fde48d213b","title":"tauri个人入门建议","content":"前言\n\n\n\n\n\nTIP\n✨如果你没有接触过相关的前端内容（简单理解为就是你放这么多东西在这我也不知道这些前端怎么玩😤）。我强烈建议你通过官方文档中的自主构建而不是使用$cargo cteate-tauri-app来进行入门🦀（博主在最开始的时候尝试了它。它会一次性为你提供整个完整的代码框架，主要在于前端框架🤔但是假如你希望边学边做，我还是建议从自建开始😎毕竟一下子接触一大堆的代码，学习曲线真的很高🥲）\n\n安装tauri无论你希望如何开始你的工作。tauri依赖是必须安装的。你可以直接ctrl+R打开cmd。输入：\n1cargo install tauri-cli\n\n安装时间比较长，你可能要稍等一下。注意你的杀毒软件。博主在安装的时候就碰到杀毒软件杀死安装过程中装入的一些依赖（我使用的是迈克菲😡体验真的有点烂了。添加白名单怎么也加不进去，而且不能直接复制路径来快速移动到想要的路径😤），被狠狠的恶心到了。\n\n\n\n\n\n\nTIP\n在所有的工作之前，你必须安装rust和一些相关的内容，这些请参考一些其他的文章，比如安装 Rust 环境 - Rust语言圣经(Rust Course)\n\n\n新建文件夹✨假如你是github的常客。我的建议是在github上创建项目。添加README和LICENSE（不会有人不喜欢为自己的项目添加README吧😺）然后直接通过git clone到本地。接下来在项目路径下打开终端\n12mkdir uicargo tauri init\n\n\n您应用的名字是什么？这将会是您打包后和操作系统会调用的应用名称。 您可以在此处填写任何您想要的名称。\n\n窗口标题叫什么？这将会是您主窗口的默认标题。 您可以在此处填写任何您想要的名称。\n\n前端页面资源 (HTML&#x2F;CSS&#x2F;JS) 相对于 &lt;current dir&gt;/src-tauri/tauri.conf.json 文件将被创建的位置？\n这是环境时tauri加载web前端资源的目录（使用..&#x2F;ui)\n\n开发环境时的加载路径?\n可以是一个网络地址也可以是一个文件路径（使用..&#x2F;ui）\n\n你将使用什么命令来开发前端页面？\n这是启动前端开发服务器的命令(我建议留空)\n\n你将使用什么命令来构建前端页面？\n这是构建前端文件的命令（我建议留空）\n\n\n然后在ui目录下面新建一个简单的index.html文件\n1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;文档&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1&gt;这是来自 Tauri 的欢迎！&lt;/h1&gt;  &lt;/body&gt;&lt;/html&gt;\n\n✨到此，你就完成了所有基础安装。可以开始你的构筑了。\n\n\n\n\n\n\nTIP\n也许在这之前你应该运行这两段代码\n12cargo tauri buildcargo tauri dev\n\n在你的项目目录下。第一次编译的时间会比较长\n假如你运行的时候产生报错了，那种很奇怪的报错。我推荐检查一下tauri.conf.json中的build字段中这两个字段是否为空。\n12345678&#123;&quot;build&quot;: &#123;\t&quot;beforeBuildCommand&quot;: &quot;&quot;,\t&quot;beforeDevCommand&quot;: &quot;&quot;，\t...\t&#125;,...&#125;\n\n个人感觉，如果你习惯使用cargo进行包管理，这样做是最方便的😺。\n\n\n✨当然，你也可以直接使用$cargo cteate-tauri-app来开始你的工作，这种方式更加简单快捷，相当于直接下载模板框架\n✨到此，你应该能够完成tauri的初步安装。通过$cargo tauri dev打开你所安装的模板程序😎\n🤔如果你出现了什么奇怪的问题也可以跟我分享🤔\n","slug":"tauri-start-tutorial","date":"2024-04-27T12:25:49.000Z","categories_index":"Rust,tauri","tags_index":"rust,tauri","author_index":"RaphaelNY"},{"id":"cb74cf4ec6063240bdd2492df0bbdf14","title":"Rust desktop application","content":"Rust Desktop Application Development Practice在这一篇中准备记录一下本此次项目从选择到构筑实现的各种心路历程。而具体遇到的问题和注意应该会单独开一篇来记录。\n\norigin这两天看到了这个视频📺，关于使用tauri+后端Rust🦀+数据库SurrealDB实现的一个桌面应用。\n恰好最近正在学习rsut🦀和数据库的相关知识，所以想要制作一个类似的✨桌面应用。前端使用什么还没有确定下来🤔。后端和数据库准备使用Rust🦀和SurrealDB。接下来准备开这个坑😎😎\n\n\n\n\n\n\nTIP\n✨[使用Rust、Tauri和SurrealDB构建令人惊叹的桌面应用程序]中字\n\ndate: 2024-04-26\n\nbuild a tauri app✨经过讨论，我们最终决定使用tauri来作为我们的工具进行我们的app构筑😎\n✨也许我们的前端选择非常愚蠢。但是我们希望我们的前端ui能够实现我们的一些异想天开🧠\n✨最终选择最为基础的使用HTML、CSS、JavaScript来作为我们的前端语言实现🤔 \nproject introduce\n项目名：Lumijade\n本次项目将由我们组织**VernunftIstWirklich** 中的三个人共同开发💕\n\n—- 待续 —-\ndate: 2024-04-27\n","slug":"Rust-desktop-application","date":"2024-04-26T15:07:08.000Z","categories_index":"Rust,tauri","tags_index":"rust,SurrealDB,tauri","author_index":"RaphaelNY"},{"id":"f8b5cac907ef39197862c4a0ab4ae287","title":"Welcome to my blog","content":"welcome to my blog希望每一位到来的访客都能够学习到，或者了解到有趣的东西😎😎\n我也会尽我所能的更新有趣的内容！😊😊\n当然，你也可以在本篇文章的评论中提出批评建议😣。或者你希望我去学习了解什么内容🤔\n当然，由于是学生的问题🧑‍🎓，我的更新是不定期的哟😘\n","slug":"Welcome-to-my-blog","date":"2024-04-26T03:23:27.000Z","categories_index":"announcement","tags_index":"announcement","author_index":"RaphaelNY"}]