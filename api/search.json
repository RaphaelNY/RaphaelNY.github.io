[{"id":"52d0fe63d1c1ad7c08273efe980dc2ed","title":"Solana escrow合约 编程学习","content":"前言苦于solana入门门槛，对于博主这样的区块链小白而言，确实有些幸苦😭。所以，经过查询，找到了一篇简单的入门教程📖。\n同时，这是本次学习的源文章\n\n\n\n\n\n\nTIP\n如果你对於区块链没有任何知识，或者说你完全没了解solana，你也许可以先考虑以下video和文档\n\n📺【Solana开发课】学习使用Rust+JavaScript进行Solana区块链开发 | 掌握 Web3、DApp、NFT、DeFi等产品开发 | 中文字幕\n📖介绍 | Solana中文大全 (solana-cn.com)\n📖Home | Solana Validator (solanalabs.com)\n📖Solana Documentation | Solana\nSolana 智能合约指南 | 登链社区 | 区块链技术社区 (learnblockchain.cn)\n\n这边建议使用②的文档，有一说一④的zh翻译真的是翻一半😤我还是倾向于看人话翻译出来的\n\n\n前期准备安装Solana-cil。我还是推荐使用⚙️Cargo来进行包管理，而不是使用其他途径进行安装🤗装不了建议换网\n1cargo install solana-cli --locked --version 1.9.1\n\n\n注意你的⚙️rust最好使用最新的版本，solana-cil的版本也建议使用最新的，详细可以参考crate.io^1。\n\n项目创建1cargo new escrow --lib\n\n\n\n\n\n\n\nTIP\n注意，下述文件除了.toml文件，其余都在.&#x2F;src&#x2F;目录下\n\n\n123Xargo.toml // 文件名[target.bpfel-unknown.dependencies.std]features = []\n\n1234567891011121314151617Cargo.toml[package]name = &quot;escrow&quot;version = &quot;0.1.0&quot;edition = &quot;2021&quot;[features]no-entrypoint = [][dependencies]arrayref = &quot;0.3.6&quot;solana-program = &quot;2.0.8&quot;thiserror = &quot;1.0&quot;spl-token = &#123;version = &quot;6.0.0&quot;, features = [&quot;no-entrypoint&quot;]&#125;[lib]crate-type = [&quot;cdylib&quot;, &quot;lib&quot;]\n\n\n第一个项目要学习的是一个托管合约，主要是解决交易中的去信任问题。\n在区块链中，智能合约双方均可见，属于天然的可信第三方👮‍♂️。\n不过，理论是理论🤗solana并不完全适用，因为solana合约是可以升级的，有可能你看到的不一定是被部署的，不过这都不重要🤔我们暂时涉及不到那个部分\n\n\n\n\n\n\n\n\n\n\n基于我个人的理解，智能合约就是承担一笔交易的第三方担保，用来保证一场交易中不会产生交易双方由于无法信任对方或者缺少可信任的第三方导致交易无法正常进行。打个不恰当的比喻，有点像是通过支付宝 || 微信进行的交易，大家都能够完全的信任，就是因为他们在我们的交易中提供了资金交流的保证。\n\n\n\n\n\n\nTIP\n在Solana区块链中，智能合约是无状态的，不能保存任何数据。所有需要保存的数据均保存在账号的data字段中。\n关于Spl-token及账号相关的一些基础知识请读者自行阅读相应文章或者源教学文章。\n\n\n\n在src目录下创建error.rs ,instruction.rs, processor.rs,entrypoint.rs,state.rs稍后我们将在这些文件中撰写代码\n\n编写基本框架\n\n\n\n\n\n\n\n\n下面会先放源码，再放我的个人理解，只想看代码的可以通过大纲进行跳转。\nError.rs12345678910111213141516use thiserror::Error;use solana_program::program_error::ProgramError;#[derive(Error,Debug,Copy,Clone)]pub enum EscrowError &#123;    // Invalid instruction    #[error(&quot;Invalid Instruction&quot;)]    InvalidInstruction,&#125;impl From&lt;EscrowError&gt; for ProgramError &#123;    fn from(e: EscrowError) -&gt; Self &#123;        ProgramError::Custom(e as u32)    &#125;&#125;\n\n\n\n\n\n\n\n\n\n\n这里使用thiserror的原因原文中写的很明确，省去我们手动实现相关Trait。\n\nsolana程序的返回值通常为ProgramError,所以我们在这里为ProgramError枚举中的所有类型实现FromTrait转换为EscrowError\n\ninstruction.rs12345678910111213141516171819202122232425262728293031323334353637383940414243use std::convert::TryInto;use crate::error::EscrowError::InvalidInstruction;use solana_program::program_error::ProgramError;pub enum EscrowInstruction &#123;    /// 因为要在初始化里转移临时代币账号所有权，所以需要原owner签名，并且原owner也是初始化者    /// 0. `[signer]` The account of the person initializing the escrow    /// 1. `[writable]` Temporary token account that should be created prior to this instruction and owned by the initializer    /// 2. `[]` The initializer&#x27;s token account for the token they will receive should the trade go through    /// 3. `[writable]` The escrow account, it will hold all necessary info about the trade.    /// 4. `[]` The rent sysvar    /// 5. `[]` The token program    InitEscrow &#123;        /// The amount party A expects to receive of token Y        amount: u64    &#125;&#125;impl EscrowInstruction &#123;    pub fn unpack(input: &amp;[u8]) -&gt; Result&lt;Self, ProgramError&gt; &#123;        let (tag, rest) = input.split_first().ok_or(InvalidInstruction)?;                Ok(match tag &#123;            0 =&gt; Self::InitEscrow &#123;                amount: Self::unpack_amount(rest)?,            &#125;,            //注意这里的用法，InvalidInstruction转化为ProgramError时，使用了into          \t//因为我们在error.rs中已经实现了那个from，系统会自动帮我们实现into            _ =&gt; return Err(InvalidInstruction.into()),        &#125;)    &#125;    //这里学习Input 转化为u64    fn unpack_amount(input: &amp;[u8]) -&gt; Result&lt;u64, ProgramError&gt; &#123;        let amount = input            .get(..8)            .and_then(|slice| slice.try_into().ok())            .map(u64::from_le_bytes)            .ok_or(InvalidInstruction)?;        Ok(amount)    &#125;&#125;\n\n\n在这段代码里准备一份初始化指令，编写unpack函数用来将输入数据解析为一个指令\n\n后续添加新的指令继续在unpack函数中添加内容即可。注意函数返回类型Result&lt;Self, ProgramError&gt;\n\n由于input是&amp;[u8]类型，我们在初始化代币所有权中使用了amount: u64,所以我们需要编写一个类型转换，从input中切取代表amount的部分。\n\n整个过程的目的是尝试从 input 的前 8 个字节中读取一个 u64 值：\n获取前 8 个字节：通过 input.get(..8) 尝试获取切片的前 8 个字节。\n转换切片到数组：使用 .and_then 和 try_into() 将字节切片转换为一个固定大小的字节数组 [u8; 8]。\n**转换字节数组到 u64**：使用 map(u64::from_le_bytes) 将 [u8; 8] 转换为 u64。\n错误处理：如果任何一步失败，返回 InvalidInstruction 错误。\n\n\n\n\n\nprocessor.rs12345678910111213141516171819202122232425262728293031323334353637use solana_program::&#123;    account_info::&#123;next_account_info,AccountInfo&#125;,    entrypoint::ProgramResult,    program_error::ProgramError,    msg,    pubkey::Pubkey,&#125;;use crate::instruction::EscrowInstruction;pub struct Processor;impl Processor &#123;    pub fn process(program_id: &amp;Pubkey, accounts: &amp;[AccountInfo], instruction_data: &amp;[u8]) -&gt; ProgramResult &#123;        let instruction = EscrowInstruction::unpack(instruction_data)?;                match instruction &#123;            EscrowInstruction::InitEscrow &#123;amount&#125; =&gt; &#123;                msg!(&quot;Instruction: InitEscrow&quot;);                Self::process_init_escrow(accounts,amount,program_id)            &#125;        &#125;    &#125;    fn process_init_escrow(        accounts: &amp;[AccountInfo],        amount: u64,        program_id: &amp;Pubkey    ) -&gt; ProgramResult &#123;        let account_info_iter = &amp;mut accounts.iter();        let initializer = next_account_info(account_info_iter)?;        if !initializer.is_signer &#123;            return Err(ProgramError::MissingRequiredSignature);        &#125;\t\t\t\t// todo        Ok(())    &#125;&#125;\n\n\n\n\n\n\n\nTIP\n\n这里一般为固定的Processor结构体（只是约定，无强制力）。在该结构体上创建一个静态函数process来处理入口转发过来的参数。在该函数内部，首先解析指令，然后根据指令调用相应的处理函数。\nprocessor返回的是ProgramResult。\n函数体中?操作符的使用，向上级调用传递错误。\n\n\nprocess_init_escrow并没有完全编写🤗后续会进行编写\n\n\n\nentrypoint.rs123456789101112131415161718//! Program entrypointuse crate::&#123;processor::Processor&#125;;use solana_program::&#123;    account_info::AccountInfo,     entrypoint,     entrypoint::ProgramResult,    pubkey::Pubkey,&#125;;entrypoint!(process_instruction);fn process_instruction(    program_id: &amp;Pubkey,    accounts: &amp;[AccountInfo],    instruction_data: &amp;[u8],) -&gt; ProgramResult &#123;    Processor::process(program_id, accounts, instruction_data) &#125;\n\n\n这部分在lib.rs中声明mod的时候，需要设定可关闭entrypoint特性，为了程序可以方便的被其他程序导入（这里原文中也只是指出了方法，是参考spl-token中的设置和编写而来的）^2\n\nstate.rs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576use solana_program::&#123;    program_pack::&#123;IsInitialized, Pack, Sealed&#125;,    program_error::ProgramError,    pubkey::Pubkey,&#125;;pub struct Escrow &#123;    pub is_initialized: bool,    pub initializer_pubkey: Pubkey,    pub temp_token_account_pubkey: Pubkey,    pub initializer_token_to_receive_account_pubkey: Pubkey,    pub expected_amount: u64,&#125;impl Sealed for Escrow &#123;&#125;impl IsInitialized for Escrow &#123;    fn is_initialized(&amp;self) -&gt; bool &#123;        self.is_initialized    &#125;&#125;use arrayref::&#123;array_mut_ref, array_ref, array_refs, mut_array_refs&#125;;impl Pack for Escrow &#123;    const LEN: usize = 105;    fn unpack_from_slice(src: &amp;[u8]) -&gt; Result&lt;Self, ProgramError&gt; &#123;        let src = array_ref![src, 0, Escrow::LEN];        let (            is_initialized,            initializer_pubkey,            temp_token_account_pubkey,            initializer_token_to_receive_account_pubkey,            expected_amount,        ) = array_refs![src, 1, 32, 32, 32, 8];        let is_initialized = match is_initialized &#123;            [0] =&gt; false,            [1] =&gt; true,            _ =&gt; return Err(ProgramError::InvalidAccountData),        &#125;;        Ok(Escrow &#123;            is_initialized,            initializer_pubkey: Pubkey::new_from_array(*initializer_pubkey),            temp_token_account_pubkey: Pubkey::new_from_array(*temp_token_account_pubkey),            initializer_token_to_receive_account_pubkey: Pubkey::new_from_array(*initializer_token_to_receive_account_pubkey),            expected_amount: u64::from_le_bytes(*expected_amount),        &#125;)    &#125;    fn pack_into_slice(&amp;self, dst: &amp;mut [u8]) &#123;        let dst = array_mut_ref![dst, 0, Escrow::LEN];        let (            is_initialized_dst,            initializer_pubkey_dst,            temp_token_account_pubkey_dst,            initializer_token_to_receive_account_pubkey_dst,            expected_amount_dst,        ) = mut_array_refs![dst, 1, 32, 32, 32, 8];        let Escrow &#123;            is_initialized,            initializer_pubkey,            temp_token_account_pubkey,            initializer_token_to_receive_account_pubkey,            expected_amount,        &#125; = self;        is_initialized_dst[0] = *is_initialized as u8;        initializer_pubkey_dst.copy_from_slice(initializer_pubkey.as_ref());        temp_token_account_pubkey_dst.copy_from_slice(temp_token_account_pubkey.as_ref());        initializer_token_to_receive_account_pubkey_dst.copy_from_slice(initializer_token_to_receive_account_pubkey.as_ref());        *expected_amount_dst = expected_amount.to_le_bytes();    &#125;&#125;\n\n\n\n\n\n\n\nTIP\n\n相同目录创建state.rs，文件用来定义状态保存对象并编写相应的程序处理序列化和反序列化（也就是将字节数组和数据结构相互转换）\n我们的结构需要实现program_pack::&#123;IsInitialized, Pack, Sealed&#125; 这三个特型。\nconst LEN: usize = 105;这里结构的大小是根据各个字段的大小相加得到的，分别为1 + 32*3 + 8 = 105。\nunpack_from_slice与pack_into_slice并不是直接被程序的其它部分调用的，Pack特型有两个默认函数，分别调用这两个函数。\n注意array_mut_ref, array_ref, array_refs, mut_array_refs这几个宏的用法，看名字就能猜到，分别为得到一个数组的可变引用，得到一个数组的引用 ，得到多个数组的引用，得到多个数组的可变引用。\n注意示例中从字节数组得到公钥的方法copy_from_slice\n示例中从字节数组得到u64采用了to_le_bytes左对齐的方式，Rust中还有类似的右对齐方式。但一般Solana中采用类C的左对齐方式。\n布尔值可以直接转换为u8，见is_initialized as u8。\n\n\n\nlib.rs123456#[cfg(not(feature = &quot;no-entrypoint&quot;))]mod entrypoint;pub mod error;pub mod instruction;pub mod processor;pub mod state;\n\n","slug":"Solana-coding-learning","date":"2024-09-01T14:56:16.000Z","categories_index":"Rust,区块链","tags_index":"rust,solana","author_index":"RaphaelNY"},{"id":"8c17d3487aed17c3a795749d1b71c388","title":"碎碎念的emo情绪","content":"","slug":"emo-time","date":"2024-04-27T16:00:00.000Z","categories_index":"Emo","tags_index":"emo","author_index":"RaphaelNY"},{"id":"3b9e33d00820bf2a8cfa74fde48d213b","title":"tauri个人入门建议","content":"前言\n\n\n\n\n\nTIP\n✨如果你没有接触过相关的前端内容（简单理解为就是你放这么多东西在这我也不知道这些前端怎么玩😤）。我强烈建议你通过官方文档中的自主构建而不是使用$cargo cteate-tauri-app来进行入门🦀（博主在最开始的时候尝试了它。它会一次性为你提供整个完整的代码框架，主要在于前端框架🤔但是假如你希望边学边做，我还是建议从自建开始😎毕竟一下子接触一大堆的代码，学习曲线真的很高🥲）\n\n安装tauri无论你希望如何开始你的工作。tauri依赖是必须安装的。你可以直接ctrl+R打开cmd。输入：\n1cargo install tauri-cli\n\n安装时间比较长，你可能要稍等一下。注意你的杀毒软件。博主在安装的时候就碰到杀毒软件杀死安装过程中装入的一些依赖（我使用的是迈克菲😡体验真的有点烂了。添加白名单怎么也加不进去，而且不能直接复制路径来快速移动到想要的路径😤），被狠狠的恶心到了。\n\n\n\n\n\n\nTIP\n在所有的工作之前，你必须安装rust和一些相关的内容，这些请参考一些其他的文章，比如安装 Rust 环境 - Rust语言圣经(Rust Course)\n\n\n新建文件夹✨假如你是github的常客。我的建议是在github上创建项目。添加README和LICENSE（不会有人不喜欢为自己的项目添加README吧😺）然后直接通过git clone到本地。接下来在项目路径下打开终端\n12mkdir uicargo tauri init\n\n\n您应用的名字是什么？这将会是您打包后和操作系统会调用的应用名称。 您可以在此处填写任何您想要的名称。\n\n窗口标题叫什么？这将会是您主窗口的默认标题。 您可以在此处填写任何您想要的名称。\n\n前端页面资源 (HTML&#x2F;CSS&#x2F;JS) 相对于 &lt;current dir&gt;/src-tauri/tauri.conf.json 文件将被创建的位置？\n这是环境时tauri加载web前端资源的目录（使用..&#x2F;ui)\n\n开发环境时的加载路径?\n可以是一个网络地址也可以是一个文件路径（使用..&#x2F;ui）\n\n你将使用什么命令来开发前端页面？\n这是启动前端开发服务器的命令(我建议留空)\n\n你将使用什么命令来构建前端页面？\n这是构建前端文件的命令（我建议留空）\n\n\n然后在ui目录下面新建一个简单的index.html文件\n1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;文档&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1&gt;这是来自 Tauri 的欢迎！&lt;/h1&gt;  &lt;/body&gt;&lt;/html&gt;\n\n✨到此，你就完成了所有基础安装。可以开始你的构筑了。\n\n\n\n\n\n\nTIP\n也许在这之前你应该运行这两段代码\n12cargo tauri buildcargo tauri dev\n\n在你的项目目录下。第一次编译的时间会比较长\n假如你运行的时候产生报错了，那种很奇怪的报错。我推荐检查一下tauri.conf.json中的build字段中这两个字段是否为空。\n12345678&#123;&quot;build&quot;: &#123;\t&quot;beforeBuildCommand&quot;: &quot;&quot;,\t&quot;beforeDevCommand&quot;: &quot;&quot;，\t...\t&#125;,...&#125;\n\n个人感觉，如果你习惯使用cargo进行包管理，这样做是最方便的😺。\n\n\n✨当然，你也可以直接使用$cargo cteate-tauri-app来开始你的工作，这种方式更加简单快捷，相当于直接下载模板框架\n✨到此，你应该能够完成tauri的初步安装。通过$cargo tauri dev打开你所安装的模板程序😎\n🤔如果你出现了什么奇怪的问题也可以跟我分享🤔\n","slug":"tauri-start-tutorial","date":"2024-04-27T12:25:49.000Z","categories_index":"Rust,tauri","tags_index":"rust,tauri","author_index":"RaphaelNY"},{"id":"cb74cf4ec6063240bdd2492df0bbdf14","title":"Rust desktop application","content":"Rust Desktop Application Development Practice在这一篇中准备记录一下本此次项目从选择到构筑实现的各种心路历程。而具体遇到的问题和注意应该会单独开一篇来记录。\n\norigin这两天看到了这个视频📺，关于使用tauri+后端Rust🦀+数据库SurrealDB实现的一个桌面应用。\n恰好最近正在学习rsut🦀和数据库的相关知识，所以想要制作一个类似的✨桌面应用。前端使用什么还没有确定下来🤔。后端和数据库准备使用Rust🦀和SurrealDB。接下来准备开这个坑😎😎\n\n\n\n\n\n\nTIP\n✨[使用Rust、Tauri和SurrealDB构建令人惊叹的桌面应用程序]中字\n\ndate: 2024-04-26\n\nbuild a tauri app✨经过讨论，我们最终决定使用tauri来作为我们的工具进行我们的app构筑😎\n✨也许我们的前端选择非常愚蠢。但是我们希望我们的前端ui能够实现我们的一些异想天开🧠\n✨最终选择最为基础的使用HTML、CSS、JavaScript来作为我们的前端语言实现🤔 \nproject introduce\n项目名：Lumijade\n本次项目将由我们组织**VernunftIstWirklich** 中的三个人共同开发💕\n\n—- 待续 —-\ndate: 2024-04-27\n","slug":"Rust-desktop-application","date":"2024-04-26T15:07:08.000Z","categories_index":"Rust,tauri","tags_index":"rust,SurrealDB,tauri","author_index":"RaphaelNY"},{"id":"f8b5cac907ef39197862c4a0ab4ae287","title":"Welcome to my blog","content":"welcome to my blog希望每一位到来的访客都能够学习到，或者了解到有趣的东西😎😎\n我也会尽我所能的更新有趣的内容！😊😊\n当然，你也可以在本篇文章的评论中提出批评建议😣。或者你希望我去学习了解什么内容🤔\n当然，由于是学生的问题🧑‍🎓，我的更新是不定期的哟😘\n","slug":"Welcome-to-my-blog","date":"2024-04-26T03:23:27.000Z","categories_index":"announcement","tags_index":"announcement","author_index":"RaphaelNY"}]